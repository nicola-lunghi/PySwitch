/**
 * Main application controller
 */
class Controller {

    VERSION = "?.0";            // For productive releases, the first three numbers should always match the PySwitch version. The last is the UI version.

    ui = null;                  // User Interface implementation
    routing = null;             // sammy.js router

    midi = null;                // MIDI handler
    device = null;              // Device handler (Controller, like Midi Captain)
    client = null;              // Client handler (like Kemper Player)
    pyswitch = null;            // PySwitch runner (in browser)

    currentConfig = null;       // Currently loaded Configuration instance
    
    /**
     * Options:
     * {
     *     // UI options:
     *     containerElementSelector: "body",       DOM Selector for the container DOM element the ui should be built in 
     *                                             (optional, default: "body")
     * 
     *     // Python options:
     *     domNamespace: "pyswitch",               ID prefix for access to DOM elements from Python code. All elements generated by python code will 
     *                                             be prefixed with this. Optional, default is "pyswitch".
     *                                             Explanation: Python code searches its elements via ID selectors. To avoid conflicts, this option has to be present.
     * 
     *     updateIntervalMillis: 20,               Tick interval in milliseconds. On CircuitPython, the program does as much ticks as it can (in a while True loop),
     *                                             which in a browser woult block all user interaction, so the ticks are triggered in intervals. Optional, default is 20.
     * }
     */
    constructor(options = {}) {
        // Defaults
        if (!options.containerElementSelector) {
            options.containerElementSelector = "body";
        }
        if (!options.domNamespace) {
            options.domNamespace = "pyswitch";
        }
        if (!options.updateIntervalMillis) {
            options.updateIntervalMillis = 20;
        }

        // Set up handlers
        this.ui = new PySwitchUI(this, options);

        this.midi = new MidiHandler();

        this.pyswitch = new PySwitchRunner(options, options.domNamespace + "-device");    
        this.device = new DeviceController(this);
        this.client = new ClientController(this);
    }

    /**
     * Run the app.
     */
    async run() {
        // Initialize MIDI
        await this.midi.init();

        // Initialize UI (settings panel etc.)        
        await this.ui.build();

        // Routing handler: Runs routing. see Routing.js for the callbacks which in turn call this controller again.
        this.routing = new Routing(this);
        this.routing.run();
    }

    /**
     * Handle exceptions
     */
    handle(e) {
        this.ui.message(e, "E");
    }

    /**
     * Scans for controllers and navigate to load its configuration
     */
    async scanControllers() {
        console.log("Scanning ports for MidiBridges...");

        const that = this;
        await this.device.scan(
            // onSuccess
            function(connection) {
                setTimeout(function() {
                    // Detach the bridge (scanning will just call a redirect which creates its own bridge)
                    that.device.bridge.detach(connection.bridge);

                    // Redirect to the found controller's URL
                    that.routing.call(that.getControllerUrl(connection.name));
                }, 0);
            },

            // onFailure
            function() {
                setTimeout(function() {
                    // Redirect to the default config
                    that.routing.call(that.getControllerUrl("pyswitch-default"));
                }, 0);
            }
        );
    }

    /**
     * Run PySwitch with a specific Configuration instance.
     */
    async loadConfiguration(config) {
        this.ui.notifications.reset();

        if (!this.ui.confirmIfDirty()) return;

        this.currentConfig = null;

        // Initialize PySwitch (this starts Pyodide and copies all necessary sources to the Emscripten virtual file system)
        this.ui.progress(0.1, "Initialize emulator");

        await this.pyswitch.init();

        // Init configuration
        this.ui.progress(0.4, "Initialize configuration");

        await config.init(this.pyswitch);

        // Get PySwitch version
        this.ui.progress(0.4, "Initialize UI");

        this.VERSION = this.VERSION.replace('?', await this.pyswitch.getVersion());
        this.ui.updateVersion()

        // Initialize client (scan for devices)
        this.ui.progress(0.5, "Initialize client device");
        
        await this.client.init(config);

        const that = this;
        this.pyswitch.setProtocolStateCallback(function(state) {
            switch(state) {
                case 10:  // Offline
                    break;
                case 20:  // Running
                    that.ui.clientButton.setState(ClientConnectionButton.STATE_CONNECTED);
                    break;
            }
        });

        // Stop the engine
        this.ui.progress(0.6, "Stop engine");

        await this.pyswitch.stop();

        // Generate parser UI, show name of config, CSS classes etc.
        this.ui.progress(0.7, "Setup UI");

        await this.ui.applyConfig(config);

        // Run local PySwitch with the config
        this.ui.progress(0.8, "Run PySwitch");

        await this.pyswitch.run(await config.get());

        this.ui.progress(1);
        this.currentConfig = config;

        this.ui.message("Loaded configuration: " + (await config.name()), "S");
    }

    /**
     * Restarts the current configuration
     */
    async restart(message = null) {
        this.ui.notifications.reset();
        
        if (!this.currentConfig) {
            console.warn("No config to restart");
            return;
        }

        // Stop the engine
        await this.pyswitch.stop();

        // Recreate UI
        await this.ui.applyConfig(this.currentConfig);

        // Restart configuration
        await this.pyswitch.run(await this.currentConfig.get());
        
        if (message != "none") {
            this.ui.message(message ? message : ("Reloaded configuration: " + (await this.currentConfig.name())), "S");
        }
    }

    /**
     * Returns a href for the passed path on the current port
     */
    getControllerUrl(portName) {
        if (!portName) portName = this.device.portName();
        return encodeURI("controller/" + portName);
    }
}